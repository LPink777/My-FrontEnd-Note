# 作用域

    [栈内存]
    全局作用域：window
    私有作用域：函数执行
    块级作用域：使用let创建变量存在块级作用域
    
    [作用域链]
    当前作用域代码执行的时候遇到一个变量，我们首先看一下它是否属于私有变量，如果是当前
    作用域有变量，那么以后在私有作用域中遇到的这个变量都是私有的（闭包：私有作用保护私
    有变量不受外界干扰）；如果不是私有的变量，向其上级作用域查找，也不是上级私有作用域
    的，会继续向上查找，一直到window全局作用域为止，我们把这种`向上一级查找的机制叫做作
    用域链`；全局下有，操作的就是全局变量，全局下没有（设置：给全局对象window增加了属性
    名  ||  获取：报错）
    
# 查找私有变量

JS中的私有变量有且只有两种
* 在私有作用域变量提升阶段，声明过的变量或者函数
* 形参也是私有变量


```javascript
    //私有 total num1 num2 
    //全局 fn result
    function fn(num1,num2){
        var total = num1 + num2;
        return total;
    }
    var result = fn(100,200)
```

#### 函数执行形成一个新的私有作用域
1. 形参赋值
2. 变量提升
3. 代码自上而下执行
4. 当前栈内存（私有作用域）销毁或者不销毁


```javascript
    //全局作用域变量提升：var x,y,z; fn = AAAFFF111;
    var x = 10,
        y = 20,
        z = 30;
    function fn(x,y){
        //[私有作用域]
        //形参赋值 x = 10; y = 20
        //变量提升 var x(忽略，x这个名字已经存在了)
        console.log(x,y,z)   //z是全局变量 10，20，30
        var x = 100;  //私有的x = 100
        y = 200;  //私有的y = 200
        z = 300;  //全局的z = 300
        console.log(x,y,z)  // =>100.200.300
    }
    fn(x,y,z)   //fn执行传递的是实参（实参都是值） fn(10,20,30)
    console.log(x,y,z) 10,20,300
```

## 如何查找上级作用域

当前函数执行形成一个私有的作用域（A），A的上级作用域是谁，和他在哪执行的没关系，主要
看他是在哪个作用域下定义的，当前A的上级作用域就是谁；

```javascript
    var n = 10;
    function sum(){
        console.log(n)
    }
    ~function(){
        var n = 100;
        sum()   //=>sum的宿主环境是当前自执行函数形成的私有作用域
    }()
```